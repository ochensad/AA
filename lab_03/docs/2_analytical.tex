\chapter{Аналитический раздел}
\label{cha:analytical}
    \section{Плавная сортировка (Smoothsort)}
\par Плавная сортировка -- алгоритм сортировки выбором, разновидность пирамидальной сортировки, разработанная Э. Дейкстрой. Но, в отличии от пирамидальной сортировки, в которой используется двоичная куча, здесь исползуется специальная куча, полученная с помощью чисел Леонардо.
	\subsection*{Числа Леонардо}
\par Числа Ленонардо -- последовательность чисел, задаваемая зависимостью:
	\begin{equation}\label{formula:LeoNumbers}
	L(n) = \begin{cases}
		1, &\text{если } n = 0;\\
		1, &\text{если } n = 1;\\
		L(n-1) + L(n-2) + 1, &\text{если } n > 1.\\
	\end{cases}
\end{equation} \par где \begin{math}n\end{math} -- индекс в массиве чисел Леонардо.
	\par Абсолютно любое целое число можно представить в виде суммы чисел Леонардо, имеющих разные порядковые номера. Массив из \begin{math}n\end{math} элементов не всегда можно представить в виде одной кучи Леонардо, но любой массив можно разделить на несколько подмассивов, которые будут соответствовать разным числам Леонардо.
	\par При разбиении массива важно учитывать, что:
	\begin{enumerate}
		\item Каждая куча Чисел Леонардо представляет собой несбалансированное бинарное дерево;
		\item Корень каждой такой кучи -- это последний элемент соответствующего подмассива;
		\item Любой узел кучи со всеми своими потомками также представляет из себя леонардову кучу меньшего порядка. 
	\end{enumerate}
	\subsection*{Алгоритм}

	\begin{enumerate} \label{alg:SmoothSort}

		\item Создаем из массива кучу леонардовых куч, каждая из которых является сортирующим деревом;

			\begin{enumerate}
			\item Перебираем элементы массива слева-направо;
			\item Проверяем, можно ли с помощью текущего элемента объединить две крайние слева кучи в уже имеющейся куче леонардовых куч:

				\begin{itemize}
					\item Если да, то объединяем две крайние слева кучи в одну, текущий элемент становится корнем этой кучи, делаем просейку для объединённой кучи;
					\item Если нет, то добавляет текущий элемент в качестве новой кучи (состоящей пока из одного узла) в имеющуюся кучу леонардовых куч.
				\end{itemize}

			\end{enumerate}

		\item Извлекает из куч текущие максимальные элементы, которые перемещакем в конец неотсортированной части массива:

			\begin{enumerate}
			\item Ищем максимумы в леонардовых кучах. Так как на предыдущем этапе для куч постоянно делалась просейка, максимумы находятся в корнях этих куч;
			\item Найденный максимум (который является корнем одной из куч) меняем местами с последним элементом массива (который является корнем самой последней кучи);
			\item После этого обмена куча, в который был найден максимум перестала быть сортирующим деревом. Поэтому делаем для неё просейку;
			\item В последней куче удаляем корень, в результате чего эта куча распадается на две кучи;
			\item После перемещения максимального элемента в конец, отсортированная часть массива увеличилась, а неотсортированная часть уменьшилась;
			\item Повторить пункты а - б.
			\end{enumerate}

	\end{enumerate}
	\section{Сортировка расчёской}
	\par Основная идея сортировки расчёской заключается в том, чтобы изначально брать самое большое расстояние между сравниваемыми элементами. Затем, по мере упорядочивания массива сужать это расстояние до минимального. Таким образом, мы как бы расчёсываем массив сначала широким гребнем, потом гребнем поменьше. Этот принцип отражается в названии сортировки. Первоначальный разрыв между сравниваемыми элементами лучше брать с учётом специальной величины, называемой фактором уменьшения, оптимальное значение которой равно примерно 1,247.
	\par Сначала расстояние между элементами максимально, то есть равно размеру массива минус один. Затем, пройдя массив с этим шагом, необходимо поделить шаг на фактор уменьшения и пройти по списку вновь. Так продолжается до тех пор, пока разность индексов не достигнет единицы. В этом случае сравниваются соседние элементы как и в сортировке пузырьком, но такая итерация одна.
	\section{Сортировка слиянием}
	\par Алгоритм использует принцип «разделяй и властвуй»: задача разбивается на подзадачи меньшего размера, которые решаются по отдельности, после чего их решения комбинируются для получения решения исходной задачи. Конкретно процедуру сортировки слиянием можно описать следующим образом:
	\begin{enumerate}
		\item Если в рассматриваемом массиве один элемент, то он уже отсортирован — алгоритм завершает работу.
		\item Иначе массив разбивается на две части, которые сортируются рекурсивно.
		\item После сортировки двух частей массива к ним применяется процедура слияния, которая по двум отсортированным частям получает исходный отсортированный массив.
	\end{enumerate}
	\section*{Вывод}
\par Были рассмотрены алгоритмы сортировки расчёской, слиянием и плавная сортировка. Каждый имеет свою особенность, а конкретно сложность работы в лучшем и худшем случаях.
\newpage